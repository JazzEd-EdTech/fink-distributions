From e70324f8dd1f191556599cf60100dd0ad0b16708 Mon Sep 17 00:00:00 2001
From: Erik Verbruggen <erik.verbruggen@theqtcompany.com>
Date: Thu, 3 Dec 2015 12:50:44 +0100
Subject: [PATCH] Remove _bit_scan_{forward,reverse}

Use qCountTrailingZeroBits and qCountLeadingZeroBits from qalgorithms.h
instead. Also extended these versions for MSVC. The _bit_scan_* versions
stem from a time before the glorious days of qalgorithms.h. A big
advantage is that these functions can be used on all platforms.

Change-Id: I5a1b886371520310a7fe16e617635ea335046beb
Reviewed-by: Simon Hausmann <simon.hausmann@qt.io>
---
 src/corelib/codecs/qutfcodec.cpp |  16 +++-
 src/corelib/kernel/qmath.h       |  22 ++---
 src/corelib/tools/qalgorithms.h  | 139 +++++++++++++++++++++++++------
 src/corelib/tools/qsimd_p.h      |  53 ------------
 src/corelib/tools/qstring.cpp    |   8 +-
 5 files changed, 144 insertions(+), 94 deletions(-)

diff --git a/src/corelib/codecs/qutfcodec.cpp b/src/corelib/codecs/qutfcodec.cpp
index f1054ceb988..b4bc1583e61 100644
--- a/src/corelib/codecs/qutfcodec.cpp
+++ b/src/corelib/codecs/qutfcodec.cpp
@@ -66,6 +66,16 @@ enum { Endian = 0, Data = 1 };
 static const uchar utf8bom[] = { 0xef, 0xbb, 0xbf };
 
 #if defined(__SSE2__) && defined(QT_COMPILER_SUPPORTS_SSE2)
+static Q_ALWAYS_INLINE uint qBitScanReverse(unsigned v) Q_DECL_NOTHROW
+{
+    uint result = qCountLeadingZeroBits(v);
+    // Now Invert the result: clz will count *down* from the msb to the lsb, so the msb index is 31
+    // and the lsb index is 0. The result for _bit_scan_reverse is expected to be the index when
+    // counting up: msb index is 0 (because it starts there), and the lsb index is 31.
+    result ^= sizeof(unsigned) * 8 - 1;
+    return result;
+}
+
 static inline bool simdEncodeAscii(uchar *&dst, const ushort *&nextAscii, const ushort *&src, const ushort *end)
 {
     // do sixteen characters at a time
diff --git a/src/corelib/tools/qalgorithms.h b/src/corelib/tools/qalgorithms.h
index 854276d1508..568b9cc95cc 100644
--- a/src/corelib/tools/qalgorithms.h
+++ b/src/corelib/tools/qalgorithms.h
@@ -683,6 +683,105 @@ QT_DEPRECATED_X("Use std::binary_search") Q_OUTOFLINE_TEMPLATE RandomAccessItera
 #define QT_POPCOUNT_RELAXED_CONSTEXPR Q_DECL_RELAXED_CONSTEXPR
 #endif
 
+// Clang had a bug where __builtin_ctz/clz is not marked as constexpr.
+#if defined Q_CC_CLANG && defined __apple_build_version__ &&  __clang_major__ < 7
+#  undef QT_HAS_CONSTEXPR_BUILTIN_CTZ_CLZ
+#else
+#  define QT_HAS_CONSTEXPR_BUILTIN_CTZ_CLZ
+#endif
+
+#if defined QT_HAS_CONSTEXPR_BUILTIN_CTZ_CLZ
+#if defined(Q_CC_GNU)
+#  define QT_HAS_BUILTIN_CTZS
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE uint qt_builtin_ctzs(quint16 v) Q_DECL_NOTHROW
+{
+#  if QT_HAS_BUILTIN(__builtin_ctzs) || defined(__BMI__)
+    return __builtin_ctzs(v);
+#  else
+    return __builtin_ctz(v);
+#  endif
+}
+#define QT_HAS_BUILTIN_CLZS
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE uint qt_builtin_clzs(quint16 v) Q_DECL_NOTHROW
+{
+#  if QT_HAS_BUILTIN(__builtin_clzs) || defined(__BMI__)
+    return __builtin_clzs(v);
+#  else
+    return __builtin_clz(v) - 16U;
+#  endif
+}
+#define QT_HAS_BUILTIN_CTZ
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE uint qt_builtin_ctz(quint32 v) Q_DECL_NOTHROW
+{
+    return __builtin_ctz(v);
+}
+#define QT_HAS_BUILTIN_CLZ
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE uint qt_builtin_clz(quint32 v) Q_DECL_NOTHROW
+{
+    return __builtin_clz(v);
+}
+#define QT_HAS_BUILTIN_CTZLL
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE uint qt_builtin_ctzll(quint64 v) Q_DECL_NOTHROW
+{
+    return __builtin_ctzll(v);
+}
+#define QT_HAS_BUILTIN_CLZLL
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE uint qt_builtin_clzll(quint64 v) Q_DECL_NOTHROW
+{
+    return __builtin_clzll(v);
+}
+#elif defined(Q_CC_MSVC) && !defined(Q_OS_WINCE)
+#define QT_HAS_BUILTIN_CTZ
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE unsigned long qt_builtin_ctz(quint32 val)
+{
+    unsigned long result;
+    _BitScanForward(&result, val);
+    return result;
+}
+#define QT_HAS_BUILTIN_CLZ
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE unsigned long qt_builtin_clz(quint32 val)
+{
+    unsigned long result;
+    _BitScanReverse(&result, val);
+    // Now Invert the result: clz will count *down* from the msb to the lsb, so the msb index is 31
+    // and the lsb index is 0. The result for the index when counting up: msb index is 0 (because it
+    // starts there), and the lsb index is 31.
+    result ^= sizeof(quint32) * 8 - 1;
+    return result;
+}
+#if Q_PROCESSOR_WORDSIZE == 8
+// These are only defined for 64bit builds.
+#define QT_HAS_BUILTIN_CTZLL
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE unsigned long qt_builtin_ctzll(quint64 val)
+{
+    unsigned long result;
+    _BitScanForward64(&result, val);
+    return result;
+}
+// MSVC calls it _BitScanReverse and returns the carry flag, which we don't need
+#define QT_HAS_BUILTIN_CLZLL
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE unsigned long qt_builtin_clzll(quint64 val)
+{
+    unsigned long result;
+    _BitScanReverse64(&result, val);
+    // see qt_builtin_clz
+    result ^= sizeof(quint64) * 8 - 1;
+    return result;
+}
+#endif
+#  define QT_HAS_BUILTIN_CTZS
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE uint qt_builtin_ctzs(quint16 v) Q_DECL_NOTHROW
+{
+    return qt_builtin_ctz(v);
+}
+#define QT_HAS_BUILTIN_CLZS
+Q_DECL_CONSTEXPR Q_ALWAYS_INLINE uint qt_builtin_clzs(quint16 v) Q_DECL_NOTHROW
+{
+    return qt_builtin_clz(v) - 16U;
+}
+#endif
+#endif // QT_HAS_CONSTEXPR_BUILTIN_CTZ_CLZ
+
 } //namespace QAlgorithmsPrivate
 
 
 
